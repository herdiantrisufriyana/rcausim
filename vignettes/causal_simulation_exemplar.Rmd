---
title: "Causal Simulation Exemplar"
author: "Herdiantri Sufriyana"
date: "2024-05-18"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Causal Simulation Exemplar}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction to Causal Graphs

To generate causally-simulated data effectively, it is essential to understand how to represent cause-and-effect relationships using causal graphs. We use the `igraph` package for creating and manipulating network structures and the `ggnetwork` package for visualizing these networks within the ggplot2 framework of the `tidyverse` package. Below is how to load these libraries in R:

```{r echo=TRUE, results='hide', message=FALSE, warning=FALSE}
library(igraph)
library(ggnetwork)
library(tidyverse)
```

We will use X and Y respectively to denote a cause and an effect. Both are represented as nodes in a graph. If there is a cause-and-effect relationship between both, then an edge is drawn from X to Y. To do this, we need a 2-column data frame: (1) from, and (2) to.

```{r}
# Create a data frame for the X and Y relationship
d <- data.frame(from = "X", to = "Y")
print(d)
```

We convert the data frame into an igraph object as a directed graph.

```{r}
# Convert the data frame into an igraph object.
g <- graph_from_data_frame(d, directed = TRUE)
print(g)
```

To visualize the graph, we need to automatically determine the coordinates to plot X and Y and draw a line from X to Y.

```{r}
# Lay out the graph as a tree
g_layout <- layout_as_tree(g)

# Determine the coordinates with ggnetwork
g_coord <- ggnetwork(g, layout = g_layout)
print(g_coord)
```

To draw the graph, we utilize `ggplot` for its flexibility in customizing graph aesthetics. Use closed and curved arrows to clearly indicate the direction of the causal effect and helps prevent overlapping of arrows.

We may need to make the tree layout horizontal tree. This orientation helps in visualizing the causal flow from left to right, making it easier to follow.

```{r}
# Define the plot area
g_plot <- ggplot(g_coord, aes(x, y, xend = xend, yend = yend))

# Draw edges with closed, curved arrows to emphasize direction
g_plot <- g_plot + geom_edges(arrow = arrow(type = "closed"), curvature = 0.15)

# Add node labels
g_plot <- g_plot + geom_nodelabel(aes(label = name))

# Make the tree layout horizontal
g_plot <- g_plot + coord_flip()
g_plot <- g_plot + scale_y_reverse()

# Apply a minimal theme
g_plot <- g_plot + theme_void()

# Display the graph
print(g_plot)
```

## Vertex and edge

A variable is represented as a vertex, and a path is represented as an edge(s). Two variables may have a path between them.

```{r echo=FALSE}
print(g_plot)
```

It is also possible for two variables to have no path between them.

```{r echo=FALSE}
g_coord %>%
  ggplot(aes(x, y, xend = xend, yend = yend)) +
  geom_nodelabel(aes(label = name)) +
  coord_flip() +
  scale_y_reverse() +
  theme_void()
```

## Path

If two variables have a path between them, there are four possible paths. First, a path consists of one edge.

```{r echo=FALSE}
print(g_plot)
```

Second, a path consists of more than one edges with mediator(s). A mediator is connected by two edges: one from X to M and another from M to Y.

```{r echo=FALSE}
data.frame(from = "X", to = "M") %>%
  add_row(data.frame(from = "M", to = "Y")) %>%
  graph_from_data_frame(directed = TRUE) %>%
  ggnetwork(layout = layout_as_tree(.)) %>%
  ggplot(aes(x, y, xend = xend, yend = yend)) +
  geom_edges(arrow = arrow(type = "closed"), curvature = 0.15) +
  geom_nodelabel(aes(label = name)) +
  coord_flip() +
  scale_y_reverse() +
  theme_void()
```

Third, a path consists of more than one edges with confounder(s). A confounder is connected by two edges: one to X and another to Y.

```{r echo=FALSE}
data.frame(from = "C", to = "X") %>%
  add_row(data.frame(from = "C", to = "Y")) %>%
  graph_from_data_frame(directed = TRUE)%>%
  ggnetwork(layout = layout_as_tree(.)) %>%
  ggplot(aes(x, y, xend = xend, yend = yend)) +
  geom_edges(arrow = arrow(type = "closed"), curvature = 0.15) +
  geom_nodelabel(aes(label = name)) +
  theme_void()
```

Fourth, a path consists of more than one edges with collider(s). A collider is connected by two edges coming from X and Y to K.

```{r echo=FALSE}
data.frame(from = "X", to = "K") %>%
  add_row(data.frame(from = "Y", to = "K")) %>%
  graph_from_data_frame(directed = TRUE) %>%
  ggnetwork(layout = layout_as_tree(.)) %>%
  ggplot(aes(x, y, xend = xend, yend = yend)) +
  geom_edges(arrow = arrow(type = "closed"), curvature = 0.15) +
  geom_nodelabel(aes(label = name)) +
  scale_y_reverse() +
  theme_void()
```

# Correlation and causation

We will empirically test these theoretical distinctions by generating causally-simulated data and conducting regression analysis. For this, we utilize the `rcausim` package for data generation and the `broom` package to tidy up the results from our correlation analysis.

```{r echo=TRUE, results='hide', message=FALSE, warning=FALSE}
library(rcausim)
library(broom)
```

## The first and second paths allow both correlation and causation

We start by defining a `Functions` class based on the specified causal structure in our previous data frame `d`. This class will help specify the required arguments for each variable's function.

```{r}
path1_functions <- function_from_edge(d)
print(path1_functions)
```

Next, we define a function for X that generates a normally distributed numeric vector of length `n`.

```{r}
function_X <- function(n){
  X <- rnorm(n, mean = 0, sd = 5)
  return(X)
}
```

For Y, we create an additive function that is dependent on `X`, modeling Y as a binary categorical variable influenced by X.

```{r}
function_Y <- function(X){
  Y_num <- 0.7 * X
  Y_prob <- 1/(1 + exp(-Y_num))
  Y_cat <- ifelse(Y_prob>0.5,1,0)
  Y <- factor(Y_cat)
  return(Y)
}
```

We now define `path1_functions` using `function_X` and `function_Y`.

```{r}
path1_functions <- define(path1_functions, which = 'X', what = function_X)
path1_functions <- define(path1_functions, which = 'Y', what = function_Y)
print(path1_functions)
```

Generate data using `path1_functions`.

```{r}
set.seed(1)
path1_data <- data_from_function(path1_functions, n = 50000)
head(path1_data)
```

Finally, we perform a logistic regression to infer the correlation between X and Y.

```{r echo=TRUE, results='hide', message=FALSE, warning=FALSE}
path1_reg <- glm(Y ~ X, family = binomial(), data = path1_data)
```

```{r}
tidy(path1_reg)
```

This output should show the estimated coefficients, their standard errors, z-values, and p-values. If X has a significant effect on Y (p-value <0.05), we can infer a statistical relationship.

For the second path involving a mediator M, we create a new data frame `d2`. This data frame specifies the causal paths from X to M and then from M to Y.

```{r}
d2 <- data.frame(from = "X", to = "M")
d2 <- add_row(d2, data.frame(from = "M", to = "Y"))
print(d2)
```

A new class of `Functions` is defined using `d2` to establish the second path which involves a mediator. This step helps clarify the arguments in each functions of X, M, and Y.

```{r}
path2_functions <- function_from_edge(d2)
print(path2_functions)
```

We reuse the same function for X, where X is generated from a normal distribution.

```{r}
function_X <- function(n){
  X <- rnorm(n, mean = 0, sd = 5)
  return(X)
}
```

We also define a function for M, which is directly influenced by X.

```{r}
function_M <- function(X){
  M <- rnorm(length(X), mean = 1.5, sd = 1) * X
  return(M)
}
```

Finally, we define a function for Y as a logistic function of M.

```{r}
function_Y <- function(M){
  Y_num <- 0.7 * M
  Y_prob <- 1/(1 + exp(-Y_num))
  Y_cat <- ifelse(Y_prob>0.5,1,0)
  Y <- factor(Y_cat)
  return(Y)
}
```

We define the `path2_functions` before generating data.

```{r}
path2_functions <- define(path2_functions, which = 'X', what = function_X)
path2_functions <- define(path2_functions, which = 'M', what = function_M)
path2_functions <- define(path2_functions, which = 'Y', what = function_Y)
print(path2_functions)
```

With `path2_functions`, we generate data that represent the second path.

```{r}
set.seed(1)
path2_data <- data_from_function(path2_functions, n = 50000)
head(path2_data)
```

Another logistic regression is performed to infer the correlation between X and Y.

```{r echo=TRUE, results='hide', message=FALSE, warning=FALSE}
path2_reg <- glm(Y ~ X, family = binomial(), data = path2_data)
```

```{r}
tidy(path2_reg)
```

In this case, the regression results indicate that X has a significant effect on Y with a p-value <0.05, demonstrating that X still exerts a significant direct effect on Yï¼Œ although the effect is mediated by M.

## The third path allows correlation although there is no causation

In the third path, both X and Y are influenced by C, as shown in `d3` below.

```{r}
d3 <- data.frame(from = "C", to = "X")
d3 <- add_row(d3, data.frame(from = "C", to = "Y"))
print(d3)
```

The arguments for the functions of X, C, and Y are clarified.

We clarify the arguments in the functions for each variable based on the data frame `d3`.

```{r}
path3_functions <- function_from_edge(d3)
print(path3_functions)
```

We define a normal distribution for C.

```{r}
function_C <- function(n){
  C <- rnorm(n, mean = 0, sd = 5)
  return(C)
}
```

The value of X depends on C.

```{r}
function_X <- function(C){
  X <- rnorm(length(C), mean = 1.5, sd = 1) * C
  return(X)
}
```

Similarly, Y also depends on C.

```{r}
function_Y <- function(C){
  Y_num <- 0.7 * C
  Y_prob <- 1/(1 + exp(-Y_num))
  Y_cat <- ifelse(Y_prob>0.5,1,0)
  Y <- factor(Y_cat)
  return(Y)
}
```

The functions are connected into `path3_functions`

```{r}
path3_functions <- define(path3_functions, which = 'C', what = function_C)
path3_functions <- define(path3_functions, which = 'X', what = function_X)
path3_functions <- define(path3_functions, which = 'Y', what = function_Y)
print(path3_functions)
```

Data is generated using `path3_functions`.

```{r}
set.seed(1)
path3_data <- data_from_function(path3_functions, n = 50000)
head(path3_data)
```

A logistic regression examines the correlation between X and Y.

```{r echo=TRUE, results='hide', message=FALSE, warning=FALSE}
path3_reg <- glm(Y ~ X, family = binomial(), data = path3_data)
```

```{r}
tidy(path3_reg)
```

Results indicate a statistically significant correlation between X and Y, although there is no edge directly from X to Y.

## The fourth path allows neither correlation nor causation

In this path, both X and Y both influence K but do not influence each other. This scenario is illustrated by `d4`.

```{r}
d4 <- data.frame(from = "X", to = "K")
d4 <- add_row(d4, data.frame(from = "Y", to = "K"))
print(d4)
```

A class of `Functions` is created to clarify the arguments in the functions for X, Y, and K.

```{r}
path4_functions <- function_from_edge(d4)
print(path4_functions)
```

The function for X determines its values to be normally-distributed.

Both X and Y are independently defined with normally distributed values.

```{r}
function_X <- function(n){
  X <- rnorm(n, mean = 0, sd = 5)
  return(X)
}
```

```{r}
function_Y <- function(n){
  Y_num <- 0.7 * rnorm(n, mean = 0, sd = 5)
  Y_prob <- 1/(1 + exp(-Y_num))
  Y_cat <- ifelse(Y_prob>0.5,1,0)
  Y <- factor(Y_cat)
  return(Y)
}
```

The value of K depends on both X and Y.

```{r}
function_K <- function(X, Y){
  K_num <- 0.7 * X
  K_prob <- 1/(1 + exp(-K_num))
  Y_num <- 0.3 * as.numeric(Y)
  K_prob <- K_prob + Y_num
  K_cat <- ifelse(K_prob>0.5,1,0)
  K <- factor(K_cat)
  return(K)
}
```

Connect all functions into `path4_functions`.

```{r}
path4_functions <- define(path4_functions, which = 'X', what = function_X)
path4_functions <- define(path4_functions, which = 'Y', what = function_Y)
path4_functions <- define(path4_functions, which = 'K', what = function_K)
print(path4_functions)
```

Finally, data are generated using `path4_functions`

```{r}
set.seed(1)
path4_data <- data_from_function(path4_functions, n = 50000)
head(path4_data)
```

We then evaluate the correlation between X and Y by conducting a logistic regression.

```{r echo=TRUE, results='hide', message=FALSE, warning=FALSE}
path4_reg <- glm(Y ~ X, family = binomial(), data = path4_data)
```

```{r}
tidy(path4_reg)
```

Results shows no significant correlation between X and Y, although there is a path between them.


